Node.js:
.......

What is Node.js?

 Node.js is a platform to run js code outside web browser.
 Platform means collection of tools,libs/apis,runtime in order to build end to end apps

Why Node.js Was Created?

 Before Node.js, There was no arch for building application particullar networkbased apps using nonblocking /async programming model.

What is Blocking and What is Non Blocking(Async) Programming Model?

Runtime:
  The program which runs the code for eg : jvm
Every Runtime is a process.
Each has sub process called "Thread".
Thread executes code parallel, - multi task.
.....................................................................................
				 File Descriptors
.....................................................................................

1.File descriptors is simple array(ds)
2.File descriptor is associated with every process on os- if you run more than one process - will have more file descriptor table

 jvm---------> fd 
 browser-----> fd
 notepad ---> fd

fd is created when process is created, destroyed when process is destroyed...

FD arch:
Integer value	Name	<unistd.h> symbolic constant[1]	<stdio.h> file stream[2]
0	Standard input	STDIN_FILENO	stdin
1	Standard output	STDOUT_FILENO	stdout
2	Standard error	STDERR_FILENO	stderr

These values are standard which cant be altered.

Lets assume if you write a program to read data from the harddrive.

Process:
1.we use language high level api to start reading file from the disk
  java:
   FileInputStream fins= newFileInputStream("c:/tmp/version.txt")
   fins.read()

 java uses read api--------|jvm----will call c api(os api)---->kernal--fd

2.we use language high level api to start reading data from the network(Remote computer)
  java:
 java uses readSocket------i--------|jvm----will call c api(os api)---->kernal--fd

..

Network io and web server:

Any web server if you take, it works based on io model- socket-network io.

Traditional web server, for every client request is  handled inside server by a thread.

        "Request Per Thread model"

....................................................................................
Drawbacks of Request Per Thread Model.
   1000 req = 1000 thread
   1 million = 1 million threads


 c10k Problem
The C10k problem is the problem of optimizing network sockets to handle a large number of clients at the same time.[1] The name C10k is a numeronym for concurrently handling ten thousand connections

Solution: 
 =>How to reduce no of threads.

Evils of Thread:
 ->Thread is subject to memory.
 ->Thread is subject to cpu, cpu need to do lot of ctx switch.

Solution:
 Having  a limited no of threads , at least one or two.

Linux api to make non blocking io:

1.select + read
2.Poll ---- sends events to the process- event driven io.
3.Epoll

EPoll:
  It is a framework, introduced in linux to handle non blocking operations using event driven programming model.

EPoll introduced a concept called "event loop"

Event Loop:

Any similar arch/technology available today like node.js?

Java - with Netty
Java with Vertx
Java with Quarkus

What type apps we can build using Node.js?

You can build  concurrent non blocking network io apps....
.....................................................................................
				Node.js Programming area

1.Node REPL
2.Node and js apis
3.Node core apis
4.Styles of writing async programming
   ->Callback pattern
   ->Promise Pattern
    ->Promise with Async and await Pattern
.....................................................................................
1.Node REPL - Read Evalulate Print loop

Node REPL is used to run js programs interactive mode.

>node
node
Welcome to Node.js v16.15.0.
Type ".help" for more information.
> a=10
10
> b=20
20
> c =a + b
30
> Math.random()
0.33841885209828515
> "Hello".toUpperCase()
'HELLO'

Node.js Built in Objects;

In browser window is super most object
In Node process is super most object

node.js does not support any browser specific apis and objects
window,document,history...

Process :
 It provides information about Node.js runtime
...................................................................................
			   Node.js Core apis
....................................................................................

Non Blocking Apps
1.web apps
2.socket programming
3.file system io...

Nonblocking Applications Developement style:
............................................

1.callbacks
2.Promises
3.Async await
4.reactive programming 


1.callbacks:
  Callback is listener function which gets registered during compile time
  and exexcuted during runtime when ever the event is emitted.

Req for async programming:
 
1.You need high level which supports non blocking 
2.listener api which is called "function as parameter"

NonBlocking apis:
1.timer
   -setTimeout
   -setInterval
2.io
   web
   fs
   socket
 etc...


Basic async programming using callbacks:
//Non blocking implementations using callbacks

//hello is variable, can hold any value

function blockMe(message){
    console.log(message)
}

function sayHello(hello) {
  // hello()
  //you register listener function with high level api called setTimeout
  setTimeout(hello,5000)
}
blockMe('start')
sayHello(function(){
    console.log('hello')
})
blockMe('end')
....................................................................................
			Async logic
....................................................................................
You can pass more callback functions 

//multiple callbacks

// function login(userName, password, success, failure) {
//     if (userName === 'admin' && password === 'admin') {
//         setTimeout(success, 1000, 'Login success')
//     } else {
//         setTimeout(failure, 1000, 'Login failed')
//     }
// }
const login = (userName, password, success, failure) => {
    if (userName === 'admin' && password === 'admin') {
        setTimeout(success, 1000, 'Login success')
    } else {
        setTimeout(failure, 1000, 'Login failed')
    }
}
// login('admin', 'admin', function (status) {
//     console.log(status)
// }, function (err) {
//     console.log(err)
// })
// login('foo', 'admin', function (status) {
//     console.log(status)
// }, function (err) {
//     console.log(err)
// })

login('admin', 'admin', status => console.log(status), (err) => console.log(err))
login('foo', 'admin', status => console.log(status), (err) => console.log(err))
...................................................................................
			  Callback Chaining/Nested Callbacks
....................................................................................

The output of one callback will be input to another callback...
The result of one callback will be input to another callback...

//callback chaining.

const getUser = (resolve, reject) => {
    let user = {
        id: 1,
        name: 'Subramanian'
    }
    //user=null
    if (user) {
        setTimeout(resolve, 100, user)
    } else {
        setTimeout(reject, 100, { err: 'User not found' })
    }
}

const login = (user, resolve, reject) => {
    if (user.name === 'Subramanian') {
        setTimeout(resolve, 100, 'Login success')
    } else {
        setTimeout(reject, 100, 'login failed')
    }
}
const showDashBoard = (status, resolve, reject) => {
    if (status === 'Login success') {
        setTimeout(resolve, 100, 'Admin')
    } else {
        setTimeout(reject, 100, 'Guest')
    }
}
getUser(user => {
    console.log(user)
    login(user, status => {
        console.log(status)
        showDashBoard(status, page => console.log(page), err => {
            console.log(err)
        })
    }, err => {
        console.log(err)
    })
}, err => {
    console.log(err)
})
...................................................................................
			   callback hell
..................................................................................
getUser(user => {
    console.log(user)
    login(user, status => {
        console.log(status)
        showDashBoard(status, page => console.log(page), err => {
            console.log(err)
        })
    }, err => {
        console.log(err)
    })
}, err => {
    console.log(err)
})
Questions:

1.Whether this code is able to understand quickly
2.Whether this code is able to debug
3.Whehter this code is scalable?
4.whether this code is maintaiable?

No
 "Callback Hell"

fs.readdir(source, function (err, files) {
  if (err) {
    console.log('Error finding files: ' + err)
  } else {
    files.forEach(function (filename, fileIndex) {
      console.log(filename)
      gm(source + filename).size(function (err, values) {
        if (err) {
          console.log('Error identifying file size: ' + err)
        } else {
          console.log(filename + ' : ' + values)
          aspect = (values.width / values.height)
          widths.forEach(function (width, widthIndex) {
            height = Math.round(width / aspect)
            console.log('resizing ' + filename + 'to ' + height + 'x' + height)
            this.resize(width, height).write(dest + 'w' + width + '_' + filename, function(err) {
              if (err) console.log('Error writing file: ' + err)
            })
          }.bind(this))
        }
      })
    })
  }
})

Callback Hell:

 -It is not bug or error in code
 -It is way of writing callback based program
 -Callback based non blocking programming hard to understand,maintain,debug,scale Which 
  called as "Callback Hell".
How to write better async/non blocking code without callbacks?

-Generally without callbacks not possible to write async/non blocking code.
-Rather we can abstract complexity of writting callbacks.


In 2005, JQUERY team started with working complex callback patterns, they found callback hell problem.

They proposed a  Design pattern to write better callback programming(Async) programming.

  "Promise".

Promise is design pattern which hides complexity of callback patterns


Since Promise is design pattern, many people have implemented Promise design pattern.

1.JQuery -first promise implementation
2.many libs and frameworks

...........................................................................................

In order standarize , ECMA committe decided to include Promise Design pattern at language level .(ES 6)
2012 E6 Committe introduced promise design pattern  as  "Promise" Object  in javascript.

Promises and non blocking,async and callback hell issues:
.........................................................

features of Promise Object:

1.Promise by deafult is Async. Which implements timer api with 0 ms .

Promise can be used with any async callback based  implementations.

Objective:

 To remove callbacks in async/non blocking code. write cleaner async programming.
 To remove complex callback chaining code.


Difference between callbacks and promises:

Essentially, a promise is a returned object to which you attach callbacks, instead of passing callbacks into a function.
....................................................................................

Promise Implemenation:

1. Create Promise Object from Promise contructor
2. Create Promise object from factory apis 

Promise object methods:
1.then - success
2.catch - errors
3.finally - clean up
factory api to create Promise object
4.resolve
5.reject
.......................................
6.all
7.race

How to create Promise Object?

1.Promise factory api
2.Promise constructors api


1.Promise factory api
   -success - resolve
   -failure - reject


//how to create Promise Object using factory

function blockMe(message){
    console.log(message)
}
function getInfo() {
    return Promise.resolve('success') // factory api to create Promise Instance
}
blockMe('start')
getInfo()
    .then(res => console.log(res))
blockMe('end')


//how to create Promise Object using factory

function blockMe(message){
    console.log(message)
}
function getInfo() {
    return Promise.reject('failure') // factory api to create Promise Instance
}
blockMe('start')
getInfo()
    .catch(err=>console.log(err))
blockMe('end')

Both success and failure:
........................
const login = (userName, password) => {
    if (userName === 'admin' && password === 'admin') {
        return Promise.resolve('Login success')
    } else {
        return Promise.reject('Login failed')
    }
}
login('admin', 'admin')
    .then(res => console.log(res))
    .catch(err => console.log(err))
login('foo', 'admin')
    .then(res => console.log(res))
    .catch(err => console.log(err))
....................................................................................
			Promise constructors
..................................................................................

Promise constructors are used to convert existing callback based programming into Promise driven with explicit api binding
lets assume i want to use setTimeout with promise - Promise constructors are used...

function blockMe(message) {
    console.log(message)
}
function getInfo() {
    return new Promise((resolve, reject) => {
        let status = false
        if (status) {
            setTimeout(resolve, 500, 'Success')
        } else {
            setTimeout(reject, 500, 'Failure')
        }
    });
}
blockMe('start')
getInfo()
    .then(res => console.log(res))
    .catch(err=>console.log(err))
blockMe('end')
..................................................................................	
			Callback hell and promises
..................................................................................
//callback chaining.

const getUser = () => {
    return new Promise((resolve, reject) => {
        let user = {
            id: 1,
            name: 'Subramanian'
        }
        //user=null
        if (user) {
            setTimeout(resolve, 100, user)
        } else {
            setTimeout(reject, 100, { err: 'User not found' })
        }
    })
}

const login = user => {
    return new Promise((resolve, reject) => {
        if (user.name === 'Subramanian') {
            setTimeout(resolve, 100, 'Login success')
        } else {
            setTimeout(reject, 100, 'login failed')
        }
    })
}
const showDashBoard = (status, resolve, reject) => {
    return new Promise((resolve, reject) => {
        if (status === 'Login success') {
            setTimeout(resolve, 100, 'Admin')
        } else {
            setTimeout(reject, 100, 'Guest')
        }
    })
}
// getUser(user => {
//     console.log(user)
//     login(user, status => {
//         console.log(status)
//         showDashBoard(status, page => console.log(page), err => {
//             console.log(err)
//         })
//     }, err => {
//         console.log(err)
//     })
// }, err => {
//     console.log(err)
// })

getUser()
    .then(user => {
        console.log('get user is called')
        return login(user)
    })
    .then(status => {
        console.log('status is called')
        return showDashBoard(status)
    })
    .then(page => {
        console.log('page is called')
        console.log(page)
    })
    .catch(err => {
        console.log(err)
    })

...................................................................................
			Promise without catch block

still how to handle errors

const login = (userName, password) => {
    if (userName === 'admin' && password === 'admin') {
        return Promise.resolve('Login success')
    } else {
        return Promise.reject('Login failed')
    }
}
login('admin', 'admin')
    .then(res => console.log(res), err => console.log(err))
login('wee', 'admin')
    .then(res => console.log(res), err => console.log(err))
....................................................................................
			resource clean up activities
				 finally
...................................................................................
const login = (userName, password) => {
    if (userName === 'admin' && password === 'admin') {
        return Promise.resolve('Login success')
    } else {
        return Promise.reject('Login failed')
    }
}
login('admin', 'admin')
    .then(res => console.log(res), err => console.log(err))
    .finally(() => {
        console.log('finally')
    })
login('wee', 'admin')
    .then(res => console.log(res), err => console.log(err))
    .finally(() => {
        console.log('finally')
    })
....................................................................................
			  Promise Hell
....................................................................................

Multi thens makes code more complex to read,maintain,debug-Promise hell.

How to solve the Promise Hell?

Using async await keyword...

Async ...await keywords:

1.async keyword is used infront of function declaration- async function
2.async functions by default return promise with success result always
2.async functions can wrap expclit apis with promise.
//
async function getValue() {
    return 10 //Promise.resolve(10)
}
const res = getValue()
//console.log(res)
res.then(res => console.log(res))

async function getStock() {
    return new Promise((resolve, reject) => {
        setTimeout(resolve, 1000, 'hello')
    })
}
getStock().then(res=>console.log(res))
..........................................................................

await 
 ->resolve promises and get result without then 
sync style of async programm.....

when we use await , the function must be async other wise it will throw error.

const getUser = () => {
    return new Promise((resolve, reject) => {
        let user = {
            id: 1,
            name: 'Subramanian'
        }
        //user=null
        if (user) {
            setTimeout(resolve, 100, user)
        } else {
            setTimeout(reject, 100, { err: 'User not found' })
        }
    })
}

const login = user => {
    return new Promise((resolve, reject) => {
        if (user.name === 'Subramanian') {
            setTimeout(resolve, 100, 'Login success')
        } else {
            setTimeout(reject, 100, 'login failed')
        }
    })
}
const showDashBoard = (status, resolve, reject) => {
    return new Promise((resolve, reject) => {
        if (status === 'Login success') {
            setTimeout(resolve, 100, 'Admin')
        } else {
            setTimeout(reject, 100, 'Guest')
        }
    })
}
// getUser()
// .then(user => {
//     console.log('get user is called')
//     return login(user)
// })
// .then(status => {
//     console.log('status is called')
//     return showDashBoard(status)
// })
// .then(page => {
//     console.log('page is called')
//     console.log(page)
// })
// .catch(err => {
//     console.log(err)
// })


async function main() {

    try {
        const user = await getUser()
        const status = await login(user)
        const page = await showDashBoard(status)
        console.log(user,status,page)
    }
    catch (err) {
       console.log(err)
    }
}
main()
....................................................................................
			   Common js with async programming
....................................................................................

src/services/TodoService.js
const TODOS = require('../mock-todos/todos')

class TodoService {
    constructor() {
    }
    //sync api
    // list() {
    //     return TODOS
    // }
    //async api
    // list(callback){
    //   setTimeout(callback,100,TODOS)
    // }
    list() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 100, TODOS)
        })
    }
}
module.exports = new TodoService();

src/app.js
const todoservice = require('./services/TodoService')

async function main() {
    // const todos = todoservice.list()
    // console.log(todos)
    //todoservice.list(todos => console.log(todos))
    //todoservice.list().then(todos=>console.log(todos))
    try {
        const todos = await todoservice.list()
        console.log(todos)
    }
    catch (err) {
        console.log(err)
    }
}
main()
....................................................................................
				Node.js Core concepts
....................................................................................

Node Modules - common js:

Types of modules:

1.Custom module
  built by us
2.built in modules
   provided by node.js  
3.provided by third party/community
  libs,frameworks

Node js Built in modules:
..........................

File System io
Networking
os
etc...
https://nodejs.org/dist/latest-v16.x/docs/api/
................

1.os 

The os module provides operating system-related utility methods and properties. It can be accessed using:

const os = require('os')

// console.log(os)
console.log(`Total Memory ${os.totalmem()}`)
console.log(`Machine Arc ${os.arch()}`)
console.log(os.cpus())

./ vs ''
.........

 require('./services/TODOService');
  ->here you can see ./
  ./ -current dir

 require('os'); => 
  -here no ./ 

Why?

Note : if you are java devp, you know the classpath , how it works?


require('os');

Node internally uses a search algorthim,node always looks the folder called
 "node_modules" in the current project, if not , then it searches, the node in built 
installtion folder---c:/pf/node/node_modules--if it finds it will pick up from there else it will throw error.

require('./services/TODOService');
   it will lookup in the current dir or sub dirs only.

nternal/modules/cjs/loader.js:800
    throw err;
    ^

Error: Cannot find module 'osxx'
Require stack:
- C:\session\ibm\feb\nodems\mynodeapps\src\index.js
[90m    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:797:15)[39m
[90m    at Function.Module._load (internal/modules/cjs/loader.js:690:27)[39m
[90m    at Module.require (internal/modules/cjs/loader.js:852:19)[39m
[90m    at require (internal/modules/cjs/helpers.js:74:18)[39m
    at Object.<anonymous> (C:\session\ibm\feb\nodems\mynodeapps\src\index.js:1:32)
[90m    at Module._compile (internal/modules/cjs/loader.js:959:30)[39m
[90m    at Object.Module._extensions..js (internal/modules/cjs/loader.js:995:10)[39m
[90m    at Module.load (internal/modules/cjs/loader.js:815:32)[39m
[90m    at Function.Module._load (internal/modules/cjs/loader.js:727:14)[39m
[90m    at Function.Module.runMain (internal/modules/cjs/loader.js:1047:10)[39m {
  code: [32m'MODULE_NOT_FOUND'[39m,
  requireStack: [ [32m'C:\\session\\ibm\\feb\\nodems\\mynodeapps\\src\\index.js'[39m ]
}
////////////////////////////////////////////////////////////////////////////////////
			    Event Driven Architechture
...................................................................................

Node.js platform by default is based on  event driven arch.

Objects emit events - emitters , Object listens for events-Listeners

Much of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called "emitters") emit named events that cause Function objects ("listeners") to be called.

-How to built event driven arch.

-Most of high level non blocking apis like fs ,net uses events module underneeth.

How to create custom events and listen for them.

-producer-emitter who emits event and data.
-listener
const EventEmitter = require('events')

//event emitter
const EventEmitter = require('events')


class CustomerService extends EventEmitter {
    constructor() {
        super()
        //listener registeration
        //sales is event , 2nd parameter is listener
        this.on('sales', (event) => {
            console.log(event)
        })
    }
    buy(product) {
        this.emit('sales', product)
    }
}
let customerService = new CustomerService()
customerService.buy({ id: 1, name: 'Phone', qty: 100, price: 1000.89 })
....................................................................................
			IO

-disk io
-socket io/networking

NonBlocking IO And Blocking:

-node supports even blocking io. only disk io in blocking way
-node does not support blocking networking io.

File System:fs

-used to read , write into and from disk.

mode :

  - sync /blocking 
  - async/ non blocking

based on data read/write:

 -non streaming
 -streaming

.....................................................................................

Non Blocking file read Operations:
const fs = require('fs')
const filePath = './src/assets/info.txt';

const options = {
    encoding: 'UTF-8'
}
function blockMe(message){
    console.log(message)
}

blockMe('start')
fs.readFile(filePath, options, (err, data) => {
    if (err) throw err
    console.log(data)
})
blockMe('end')

Blocking io also supported:
..........................
const fs = require('fs')
const filePath = './src/assets/info.txt';

const options = {
    encoding: 'UTF-8'
}
function blockMe(message) {
    console.log(message)
}

blockMe('start')
const data = fs.readFileSync(filePath, options)
console.log(data)
blockMe('end')
......

How to avoid file path hardcoding?

path module:

The path module provides utilities for working with file and directory paths. It can be accessed using:

Node js global variables:

-node provides lot of global variables

__dirname  : current directory name
C:\session\ibm\2021\june\nodemicroservices\nodeapps\src

__filename :current directory name + fileName
C:\session\ibm\2021\june\nodemicroservices\nodeapps\src\index.js
const fs = require('fs');

const filePath = './src/assets/infowrite.txt';
const options = {
    encoding: 'utf-8'
}
const data = 'Hello,How are you';

fs.writeFile(filePath, data, options, err => {
  if (err) throw err;
  console.log(`data has been written into ${filePath}`)
})
...

const fs = require('fs');
const path = require('path');

console.log(__dirname)
console.log(__filename)
// const filePath = './src/assets/infowrite.txt';
const filePath = path.join(__dirname,'assets/infowrite.txt')
const options = {
    encoding: 'utf-8'
}
const data = 'Hello,How are you';

fs.writeFile(filePath, data, options, err => {
  if (err) throw err;
  console.log(`data has been written into ${filePath}`)
})
...................................................................................
				IO operations Mode

1.Non Streaming mode
2.Streaming mode.


1.Non Streaming mode:


   only file io is supported, network io not supported

-once file is read, the entire file is loaded into node process buffer(memory), then it will be delivered to caller.

-if more files are loaded into node process, node process gets crashed.

-non streaming mode is not suitable for large and big files read or write operation.

fs.readFile() and fs.writeFile are non streaming apis.

2.streaming:
   supported by fs and also network apis


-Streaming is nothing but flow of data(chunks).
-Streaming allows move the data from one place to another place one by one.
-Streaming apis are other wise called evented io. which is powered events.


Types of Streams:

1.Readable Stream : input
2.Writeable stream : output
3.Duplex stream : read + write

Node has lot of built in stream apis
....................................

Built in readable Streams:

-HTTP responses, on the client
-HTTP requests, on the server
-fs read streams
-zlib streams
-crypto streams
-TCP sockets
-child process stdout and stderr
-process.stdin

Writable Streams:

-HTTP requests, on the client
-HTTP responses, on the server
-fs write streams
-zlib streams
-crypto streams
-TCP sockets
-child process stdin
-process.stdout, process.stderr


All streaming apis are powered with events
node io streams has built in events.
events are emitted by node.
Our programs are listeners


Common events in all io
.........................


1.data event:
 which is emitted by node, for each chunk.

2.close event:
  The 'close' event is emitted when the stream and any of its underlying resources (a file descriptor, for example) have been closed.

3.end event:
 The 'end' event is emitted when there is no more data to be consumed from the stream.

3.Event: 'error'
 The 'error' event may be emitted by a Readable implementation at any time
Typically, this may occur if the underlying stream is unable to generate data due to an underlying internal failure, or when a stream implementation attempts to push an invalid chunk of data.

//Streaming
const fs = require("fs")
const path = require('path');
const fileName = path.join(__dirname, 'assets/info.txt');
const config = {
    encoding: 'UTF-8'
}
const inputStream = fs.createReadStream(fileName, config);
//events
//data event is emitted by os for each chunk of data
let data = ''
inputStream.on('data', chunk => {
    console.log(`Received ${chunk.length} bytes of data.`)
    data += chunk;
})
//end event is called , no more chunk of data is availble.
inputStream.on('end', () => {
    console.log('There will be no more data to read!');
    console.log(data);
})

//error event: for error handling
inputStream.on('error', err => {
    console.log(`Some thing went wrong! ${err}`)
});
....................................................................................
				Writter Stream

const fs = require('fs');
const path = require('path');

const fileName = path.join(__dirname, 'assets/grains.txt');

const config = {
    encoding: 'utf8',
    flag: 'w'
};
const outputStream = fs.createWriteStream(fileName, config);

const grains = ['wheat', 'rice', 'oats'];

grains.forEach(grain => {
    outputStream.write(grain + " ");
    console.log("Wrote: %s", grain);
});

outputStream.close();

outputStream.on('close', function () {
    console.log('file has been closed ')
})

.........................

Big file create:

const fs = require('fs');
const path = require('path')

const filePath = path.join(__dirname, "assets/big.file")
const file = fs.createWriteStream(filePath);

for (let i = 0; i <= 1e6; i++) {
    file.write('Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n');
}

file.end();
...................................................................................
				Big File Read
....................................................................................

const fs = require('fs');
const path = require('path');
const { log } = console;

const fileName = path.join(__dirname, 'assets/big.file');
const config = {
    encoding: 'UTF-8'
}
const inputStream = fs.createReadStream(fileName, config);

//data event is emitted by os for each chunk of data
let data = ''
inputStream.on('data', chunk=> {
    log(`Received ${chunk.length} bytes of data.`)
    data += chunk;
})

//end event is called , no more chunk of data is availble.
inputStream.on('end', () => {
    log('There will be no more data to read!');
    log(data);
})

//error event: for error handling

.....................................................................................
			How to read from one file and write into another
.....................................................................................
const fs = require('fs');
const path = require('path');

//read
const inputfileName = path.join(__dirname, 'assets/big.file');
//write
const outputFileName = path.join(__dirname, 'assets/bigcopy.file');

const config = {
    encoding: 'UTF-8'
}

const inputStream = fs.createReadStream(inputfileName, config);
const outputStream = fs.createWriteStream(outputFileName, config);

//Register data event.
inputStream.on('data', function (chunk) {
    console.log(`Received ${chunk.length} bytes of data.`);
    outputStream.write(chunk);
});


//end event
inputStream.on('end', function () {
    console.log('There will be no more data to read!');
    outputStream.close();
})

//error event: for error handling
inputStream.on('error', function (err) {
    console.log(`Some thing went wrong! ${err}`)
});

outputStream.on('close', function () {
    console.log(`File write operation is completed`);
});

Backpressure:
Problems when you do read and write together

1. In general read operation is faster than write operation


Back Pressure means inputstream is fast, outputstream slow, then data will be
lost.


How to handle back pressure?

 apis  : pause,resume,drain event

pause : to close the upstream, not to emit data
resume : to open the open upstream , to emit data

drain event: if drain event is called.

const fs = require('fs');
const path = require('path');

const inputfileName = path.join(__dirname, 'assets/big.file');
const outputfileName = path.join(__dirname, 'assets/bigcopy.file');

const config = {
    encoding: 'UTF-8'
}

//Back pressure handling
const readerStream = fs.createReadStream(inputfileName, config);
const writeStr = fs.createWriteStream(outputfileName, config);

readerStream.on('data', function (chunk) {
    console.log(`Received ${chunk.length} bytes of data.`);
    let buffer_good = writeStr.write(chunk);
    if (!buffer_good) readerStream.pause();
});
writeStr.on('drain', function () {
    console.log('buffer drained!');
    readerStream.resume();
});
readerStream.on('end', function () {
    //console.log(data);
});

readerStream.on('error', function (err) {
    console.log(err.stack);
});
...................................................................................
	   Pipe method to eleminate backpressure apis(drain,resume,pause)
...................................................................................
const fs = require('fs');
const path = require('path');

const inputfileName = path.join(__dirname, 'assets/big.file');
//write
const outputFileName = path.join(__dirname, 'assets/bigcopy.file');

const config = {
      encoding: 'UTF-8'
}

//Back pressure handling
const readerStream = fs.createReadStream(inputfileName, config);
const writeStr = fs.createWriteStream(outputFileName, config);

//backPressure streams
//pipe method is simplest method which wraps resume,pasuse,drain 
readerStream.pipe(writeStr);
.....................................................................................
			Non Blocking Web Apps
....................................................................................

Node Js Provides HTTP Server,HttpApplication , is nonblocking.

Unlike traditional webservers,node uses single event thread to handle concurrent requests.

Http Module:
The HTTP interfaces in Node.js are designed to support many features of the protocol which have been traditionally difficult to use. In particular, large, possibly chunk-encoded, messages. The interface is careful to never buffer entire requests or responses, so the user is able to stream data.

HTTP modules objects:

1.Server
  Server object is used to implement http servers/web containers
2.ServerResponse
  Object is used to send data 
3.ClientRequest
   Request object is used to handle http client requests
4.IncommingMessage
   Represents message payloads.



Note: all http implemnetation is streaming powered by default.

Steps:

1.create Server.
2.request-response handling
3.starting server

const http = require('http')
// console.log(http)

//handles all client request
const requestListener = (req, res) => {
    res.write("Hello")
    //close the stream
    res.end()
}
const server = http.createServer(requestListener)

//start the server
server.listen(8080,()=>{
    console.log('HTTP server is Running!!!')
})

.....................................................................................
const { createServer } = require('http')

//handles all client request
const server = createServer((req, res) => {
    res.write("Hello")
    //close the stream
    res.end()
})

//start the server
server.listen(8080, () => {
    console.log('HTTP server is Running!!!')
})
.....................................................................................
			 Response Types
....................................................................................

plain/text
application/json
etc...

const http = require('http')
const TODOS = require('./mock-data/todos')

const server = http.createServer((req, res) => {
    //response as json 
    res.writeHead(200, {
        'Content-Type': 'application/json'
    })
    const todos = JSON.stringify(TODOS)
    res.end(todos)

})


server.listen(8080, () => {
    console.log(`Server is running on ${server.address().port}`)
})

...................................................................................
   		  Handling biz logic in a separate layer
....................................................................................

const todos = require("../mock-data/todos")

class TodoService {
    constructor() {

    }
    //blocking api
    // findAll() {
    //     return JSON.stringify(todos)
    // }
    // findAll(callback) {
    //     setTimeout(callback, 5000, todos)
    // }
    findAll() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 5000, todos)
        })
    }
}
module.exports = new TodoService();
.....

Api layer:
const http = require('http')
const { findAll } = require('./services/Todo.service')

const server = http.createServer(async (req, res) => {
    //response as json 
    // findAll(todos => {
    //     res.writeHead(200, {
    //         'Content-Type': 'application/json'
    //     })
    //     res.end(JSON.stringify(todos))
    // })
    res.writeHead(200, {
        'Content-Type': 'application/json'
    })
    // findAll().then(todos => {
    //     res.end(JSON.stringify(todos))
    // }).catch(err => {
    //     res.end(JSON.stringify({ err: err }))
    // })
    try {
        const todos = await findAll()
        res.end(JSON.stringify(todos))
    }
    catch (err) {
        res.end(JSON.stringify({ err: err }))
    }
})


server.listen(8080, () => {
    console.log(`Server is running on ${server.address().port}`)
})
.....................................................................................
			 How to read input

const http = require('http')

const server = http.createServer((req, res) => {
    //how to read data from the client.
    //attach listener on request object
    let data = ''
    req.on('data', chunk => {
        data += chunk
    });
    req.on('end', () => {
        let res = JSON.parse(data)
        console.log(res)
    })
    res.end('hello')
});


server.listen(8080, () => {
    console.log(`Server is running on ${server.address().port}`)
})
................................................................................
			 File as response
.................................................................................
const http = require('http')
const fs = require('fs')
const path = require('path')

const server = http.createServer((req, res) => {
    const filePath = path.join(__dirname, 'assets/info.txt')
    //fileSize
    const fileSize = fs.statSync(filePath)
    res.writeHead(200, {
        'Content-Type': 'text/plain',
        'Content-Length': fileSize.size
    })
    let readStream = fs.createReadStream(filePath)
    //write into http response stream
    readStream.pipe(res)

})

server.listen(8080, () => {
    console.log(`Server is running at ${server.address().port}`)
})
.................................................................................
			Server Events
..................................................................................
request event:
 we can attach request event , which is used to listen any incoming request information.
//how to listen for server events

const http= require('http')

const server = http.createServer((req, res) => {
    //how to read data from the client.
    //attach listener on request object
    let data = ''
    req.on('data', chunk => {
        data += chunk
    });
    req.on('end', () => {
        let res = JSON.parse(data)
        console.log(res)
    })
    res.end('hello')
});

//server event listeners
server.on('request',(req,res)=>{
    console.log(req.headers)
    console.log(req.url,req.method)
    
})

server.listen(8080, () => {
    console.log(`Server is running on ${server.address().port}`)
})
..................................................................................
			TCP server and client application
...................................................................................

There is a module called "net module".

The node:net module provides an asynchronous network API for creating stream-based TCP or IPC servers (net.createServer()) and clients (net.createConnection()).



Server:
const net = require('net')

//socket tcp server 
const server = net.createServer(connection => {
    console.log('TCP server is connected')
    //events
    connection.on('end', () => {
        console.log('client is disconnected')
    })
    connection.write('Hello,TCP Server Message')
    connection.pipe(connection)
})
//server listener
server.listen(9090, () => {
    console.log('TCP server is listening')
})

Socket Client:
const net = require('net')
const client = net.connect({ port: 9090 }, () => {
    console.log('TCP client connected with Server')
});
client.on('data', data => {
    console.log(data.toString())
    client.end();
})
client.on('end', () => {
    console.log('Disconnected from the server')
})

How to run the app

>node src/socketserver.js

>node src/socketclient.js
.....................................................................................
			  NPM - Node package Manager


What is npm?
 npm is the world's largest software registry.
 open source developers from every part of the world use npm sto share and borrow packages.
 many organizations use npm to manage private development as well.

In js, you might have created lib/framework/utility, if you want to share to other developers in the world or within your organization or your team - npm helps.

NPM consists of three components
1.the website - used to discover packages, setup profiles and manage other aspects of npm

2.CLI runs from the terminal, and how most developers interact with npm.

3.registry - it is  large public database of js software and the meta information surrounding it.

core concepts in npm:

1.package
2.module

What is package?
   A package is a file or directory that is described by a package.json file
   A package must contain package.json file in order to be published to the npm    registry

Package format:
a.A folder containing a program described by a package.json.
b.A gizpped tarball containing "a"
c.A URL that resolves "a"

Modules:
 A module is any file or directory in the "node_modules" directory that can be loaded by the node.js require function
 A javascript file

modules need not have "package.json" file

eg:
 const http =require('http')

 here the variable called http referes the 'http' module.

....................................................................................
				How to create npm package

Steps:

1.create folder
>mkdir mynpm-apps
>cd mynpm-apps
>mkdir src

2.create package.json

Before create you have to ensure that npm has been installed.

npm init <initalizer>

npm init
This utility will walk you through creating a package.json file.
It only covers the most common items, and tries to guess sensible defaults.

See `npm help init` for definitive documentation on these fields
and exactly what they do.

Use `npm install <pkg>` afterwards to install a package and
save it as a dependency in the package.json file.

Press ^C at any time to quit.
package name: (mynpm-apps)
version: (1.0.0)
description:
entry point: (index.js)
test command:
git repository:
keywords:
author:
license: (ISC)

package.json
{
  "name": "mynpm-apps",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC"
}
...................................................................................
>npm init --yes

Wrote to E:\session\IBM\2022\sep\nodejs\mynpm-apps\package.json:

{
  "name": "mynpm-apps",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}
.....

name:
 This is used to publish package into registry

version:
   if you publish package into registry, which is differentiated by "version"

"1.0.0" - version no is based on the concept called "SEM Ver" concept- Semantic versioning.
 Major.minor.patch

main:
  It is main file used /entry file in the package , generally it would index.js or main.js

description:
  It explains the nature of packages- what is this packge.

Keywords:
  Used to discover your packages using npm search command

author:
  Who is author of this package

license:
  You should specify a license for your package so that people know how they are permitted to use it.
................

node_modules:
  it is folder , used to install any node packages, the node programm always looks up the packages from the current folder.
....................................................................................
				Node Packages

How to install node packages which was distributed by others?

npm install [<package-name>]

You can find out the packages from npm registry server

npm install | i  lodash --options

npm i lodash

src/index.js

//How to use lodash 
var _ = require('lodash');
console.log(_)
...........................&&&&&&&&&&&&&&&&..........................................

Options:

 --save
 --save-dev
  -g

Application mode

1.dev
2.test
3.prod

dev : any dependency required for development only
  --save-dev
test : 
   any dependency required for development only - test
   --save-dev
prod:
  dependency used in dev and production... 
  --save
"dependencies": {
    "lodash": "^4.17.21"
  }
 
Libs required for dev and test
tools
   -compilers,webservers
   -testing libs and framworks 

eg:
  mocha - test runner is used for running test case
  chai.js -test assertion lib used for writing test cases

 "devDependencies": {
    "mocha": "^10.0.0"
  }
....................................................................................
	  How to install only production dependencies during build process
....................................................................................
if you want to use app in production mode, you have exclude the dependencies.

npm i /npm install - install dev and production packages...
 --->it scans package.json file which install everything(dev + prod)

npm install --production
  it scans package.json which install only from dependencies
.....................................................................................
			How to remove /uninstall package

npm uninstall mocha --save-dev
,,,,,,,,,,,,,........................................................................
			Global Package

Global package is installed not inside project, installed globally.
Global packages are generally tools to create projects,webservers,test runtime like so.
npm install mocha -g
.....................................................................................
		     java script automation
...................................................................................
 "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },

"key"  => the command Name
"value" => task to be executed

commands:
   npm offers lot of built in script command
 
test,start,pack,publsh,install,stop,version...

How to run?
  npm commandName
  npm test
  npm start
  npm stop


node programm can be executed in two ways.

1.node src/index.js
2.npm start

{
  "name": "mynpm-apps",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start" : "node src/app.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "lodash": "^4.17.21"
  }
}
....................................................................................
			 Custom Commands
...................................................................................

if you want to run custom commands

"scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start" : "node src/app.js",
    "demo" : "node src/app.js"
  },
npm run commandName

npm run demo
....................................................................................
			  Global packages and scripts
...................................................................................
....................................................................................
	        Common Problems in Gobal Modules and how to
			 Solve using  scripts


-Global modules are used for tooling purpose like compilers,build tools,servers,test runners(mocha).

Globals has some issues:

1.version and compablity issue for new projects
1.version and compablity issue for new projects


Steps:

1.npm uninstall mocha -g

2.>mocha --help
'mocha' is not recognized as an internal or external command,
operable program or batch file.

3.install mocha locally

 npm install mocha --save-dev

4.>mocha
'mocha' is not recognized as an internal or external command,
operable program or batch file.

Why i am getting error?
  because mocha is command, we cant run directly.

5.solution is run via scripts

package.json
"scripts": {
    "test": "mocha",
    "start": "node src/index.js",
    "subu": "node src/index.js"
  }

npm test

> nodeapps@1.0.0 test C:\session\ibm\2021\june\nodemicroservices\nodeapps
> mocha



  Array
    #indexOf()
      âˆš should return -1 when the value is not present


  1 passing (6ms)
....................................................................................
			How to execute multiple scripts

we may want to coimbine some of scripts and run them together


  "scripts": {
     "hello": "node src/hello.js",
    "hai": "node src/hai.js",
    "greet": "npm run hello && npm run hai"
  },
.....................................................................................	
			Web Frameworks for Node.js
				Express.js
................................................................................

What is express.js
  Express.js is the first web framework built for node js and built by node js core team.
  Express.js is wrapper around core http module.
  Express is abstraction for creating Web Applications for node http core module.

Express can be used to small to medium scale apps only.

Types of apps we can build using express.j

1.Dynamic web apps
2.Rest apis


How to write express apps?

1.using vannila node project and install express framework
2.using express generator - tool used to create express apps.

express core concepts:
 In express everything object

express - function
  used to create express objects

1.Application
 
2.Request
3.Response
4.Router

1.Application Object
  =>It represents the whole express app
  =>It is container object which contains other objects
  =>It is created by calling express function
  =>Per Application only one app instance

Application Object
  =>You can expose the global end points
  =>You configure middlewares
  =>you can render views
  =>you can register template engines
  =>You can start web container...

Simple express app:
const express = require('express')

// console.log(express)
const app = express()

// console.log(app)
//home page:
app.get("/", (req, res) => {
    res.end('Home Page!!')
})

//start server
app.listen(3000, () => {
    console.log('Express Server is running')
})

if you build app, you have to switch very often from source code to runtime

how to enable hot reloading feature.

There is a module "nodemon"

Steps:

npm install -g nodemon

nodemon src/index.js
[nodemon] 2.0.19
[nodemon] to restart at any time, enter `rs`
[nodemon] watching path(s): *.*
[nodemon] watching extensions: js,mjs,json
[nodemon] starting `node src/index.js`
Express Server is running
[nodemon] restarting due to changes...
[nodemon] starting `node src/index.js`
Express Server is running
[nodemon] restarting due to changes...
[nodemon] starting `node src/index.js`
..........................................................................
			   REST API development
....................................................................................

HTTP Verbs:
  -GET
  -POST
  -PUT
  -DELETE

Resource:
 -UserResource
 -ProductResource
 -CustomerResource
 

const express = require('express')

// console.log(express)
const app = express()

// console.log(app)
//home page:
app.get("/", (req, res) => {
    res.end('Welcome to Express App - Home Page!!!')
})
//REST API:
app.get('/api/customers',(req,res)=>{
    res.end('Customers-Get')
})
app.post('/api/customers/create',(req,res)=>{
    res.end('Customers-POST')
})
app.put('/api/customers/update',(req,res)=>{
    res.end('Customers-UPDATE')
})
app.delete('/api/customers/remove',(req,res)=>{
    res.end('Customers-Delete')
})
app.get('/api/users',(req,res)=>{
    res.end('users-Get')
})
app.post('/api/users/create',(req,res)=>{
    res.end('USERS-POST')
})
app.put('/api/users/update',(req,res)=>{
    res.end('USERS-UPDATE')
})
app.delete('/api/users/remove',(req,res)=>{
    res.end('USERS-Delete')
})

//start server
app.listen(3000, () => {
    console.log('Express Server is running')
})
.....................................................................................
			 How to modularize the express app
.....................................................................................


						    |-----Customers
						    |-----Users
User - /api/customers/-------|Express Server|App-----
						    |-----Products
						    |-----XXX

src
  |
  index.js - root app
routers
  |
  ----customerrouter.js
services
  ----customerService.js


Router:
  A router object is isloated instance of middlewares and routes.
  You can think of it as a "mini application"

router.get
router.post
router.delete
router.put

eg:
 src/routers/customer.router.js
const express = require('express')
const customerRouter = express.Router()

customerRouter.get('/', (req, res) => {
    res.end('Customers-Get!!!')
})
customerRouter.post('/create', (req, res) => {
    res.end('Customers-POST')
})
customerRouter.put('/update', (req, res) => {
    res.end('Customers-UPDATE')
})
customerRouter.delete('/remove', (req, res) => {
    res.end('Customers-Delete')
})
//
module.exports = customerRouter;

How to create Router Object?
   The top level Express api to create router object.

const express =require('express')
const router = express.Router()


const express = require('express')
const customerRouter = require('./routers/customer.router')

const app = express()

//connecting router with application object, so that routing will happen.
app.use('/api/customers',customerRouter);

//home page:
app.get("/", (req, res) => {
    res.end('Welcome to Express App - Home Page!!!')
})

//start server
app.listen(3000, () => {
    console.log('Express Server is running')
})

Task:
 You have to complete this customer end point with CURD operation using ARRAY.
you have to use array as database.

How to read Parameters in express?

parameters :
  path parameter
    /customers/:id

req.params

  query parameter
   /customers?sort=asc

req.query  


const express = require('express')
const customerRouter = express.Router()

customerRouter.get('/', (req, res) => {
    res.end('Customers-Get!!!')
})
customerRouter.get('/:id', (req, res) => {
    const params = req.params
    console.log(params)
    res.end('Customers-Get!!!' + params.id)
})
customerRouter.get('/search/bycity', (req, res) => {
    const params = req.query
    console.log(params)
    res.end('Customers-search!!!')
})


customerRouter.post('/create', (req, res) => {
    res.end('Customers-POST')
})


customerRouter.put('/update/:id', (req, res) => {
    const params = req.params
    console.log(params)
    res.end('Customers-UPDATE')
})
customerRouter.delete('/remove/:id', (req, res) => {
      res.end('Customers-Delete')
})
//
module.exports = customerRouter;
.....................................................................................
				Express Middlwares
....................................................................................

Middlewares:
 What is Middleware?
  Middleware is javascript function that have access request object and response and next function in the application request response cycle.
  
 The difference between normal function which handles req and response with express , express takes thrird arg

 normal function
  app.get('url',(req,res)=>{})

 Middleware function
  app.get('url',(req,res,next)=>{

  })
 req and res are objects
 next is a function

The next function is a function in the express router which,when invoked,executes the middleware succeeding the current middleware.

Tasks are middleware is doing:

1.Execute any code
2.Make changes to request and response object before handling real req and res cycle.
3.Middlwares can be attached on application object and also router object

simple middleware.

const express = require('express')

const app = express();

//simple middleware
app.get('/', (req, res, next) => {
    console.log('middlware')
    next()
})
app.get('/', (req, res, next) => {
    res.end('response')
})

app.listen(8080, () => {
    console.log('Express server is running')
})
....................................................................................

Middlwares with some logic:
const express = require('express')

const app = express();

//you can intercept req do something
app.get('/', (req, res, next) => {
    console.log(req.url)
    console.log(req.headers)
    console.log(req.baseUrl)
    //set custom response header
    res.set({
        'company':'IBM'
    })
    next()
})
app.get('/', (req, res, next) => {
    res.end('response')
})

app.listen(8080, () => {
    console.log('Express server is running')
})
..................................................................................
		How to calculate the request has spend time in the 
		     request response cycle


const express = require('express')

const app = express();

//This is middlware is executed for every request irrespect of url and method
const requestTime = (req, res, next) => {
    req.requestTime = Date.now()
    next()
}
//how to attach this middlware 
app.use(requestTime)

app.get('/', (req, res, next) => {
    let responseText = '<h1>Hello World</h1>'
    responseText += `Requested at ${req.requestTime}`
    res.send(responseText)
})

app.listen(8080, () => {
    console.log('Express server is running')
})
.....................................................................................
		  Can we pass parameters to the Middleware so that we can 
			configure middleware - Configurable Middlewares
....................................................................................

src/middlwares/my-middlware.js

//custom middleware
module.exports = function (options) {
    //return middleware function
    return function (req, res, next) {
        console.log(options)
        next();
    }
}

index.js

const express = require('express')

const app = express();
const myMiddleware = require('./middlwares/my-middleware')

//configure the middleware 
app.use(myMiddleware({option1:'option1',option2:'options'}))


app.get('/', (req, res, next) => {
    res.send('Configurable middleware')
})

app.listen(8080, () => {
    console.log('Express server is running')
})
.....................................................................................
				Types of Middlewares
.....................................................................................
1.Application middleware
2.Router level middlware
3.Error handling middleware
4.Third party middleware


1.Application middleware:
  Middleware is attached on application object

const express = require('express')

const app = express();
const myMiddleware = require('./middlwares/my-middleware')

//configure the middleware 
app.use(myMiddleware({ id: 1, name: 'subramanian' }))
//global middleware is called for any request with any method
app.use((req, res, next) => {
    console.log('m2')
    next()
})
app.use((req, res, next) => {
    console.log('m3')
    next()
})
app.use((req, res, next) => {
    console.log('m4')
    next()
})


app.get('/', (req, res, next) => {
    res.send('Configurable middleware')
})
//url specific middleware
// app.get('/api/user', (req, res, next) => {
//     console.log('User Middleware')
//     next()
// })
// app.get('/api/user', (req, res, next) => {
//     res.send('user')
// })
//chaining middlwares and work flow with simple syntax
app.get('/api/user', (req, res, next) => {
    console.log('User Middleware-1')
    next()
}, (req, res, next) => {
    console.log('User Middleware2')
    next()
}, (req, res) => {
    res.send('Users')
})
app.listen(8080, () => {
    console.log('Express server is running')
})
.....................................................................................
			 Router Level Middleware

Router middleware are attached at router instance level.

const router =express.Router()

//router global
router.use((req,res,next)=>{

}))
router.use('/:id',((req,res,next)=>{

}))

eg:
const express = require('express')
const customerRouter = express.Router()

customerRouter.use((req, res, next) => {
    console.log('Customer Router Middleware')
    next()
})

customerRouter.get('/', (req, res) => {
    res.end('Customers-Get!!!')
})
customerRouter.get('/:id', (req, res) => {
    const params = req.params
    console.log(params)
    res.end('Customers-Get!!!' + params.id)
})
customerRouter.get('/search/bycity', (req, res) => {
    const params = req.query
    console.log(params)
    res.end('Customers-search!!!')
})


customerRouter.post('/create', (req, res) => {
    res.end('Customers-POST')
})


customerRouter.put('/update/:id', (req, res) => {
    const params = req.params
    console.log(params)
    res.end('Customers-UPDATE')
})
customerRouter.delete('/remove/:id', (req, res) => {
    res.end('Customers-Delete')
})
//
module.exports = customerRouter;

const express = require('express')
const customerRouter = require('./routers/customer.router')

const app = express()

//connecting router with application object, so that routing will happen.
app.use('/api/customers',customerRouter);

//home page:
app.get("/", (req, res) => {
    res.end('Welcome to Express App - Home Page!!!')
})

//start server
app.listen(3000, () => {
    console.log('Express Server is running')
})
....................................................................................
			Error Handling middleware
...................................................................................

Error handling middleware takes four args instead of three arg.

app.use((err, req, res, next)=> {
    res.status(500).send('something went wrong')
})

const express = require('express')
const customerRouter = require('./routers/customer.router')

const app = express()

//connecting router with application object, so that routing will happen.
app.use('/api/customers', customerRouter);

app.use((err, req, res, next)=> {
    res.status(500).send('something went wrong')
})


//home page:
app.get("/", (req, res) => {
    res.end('Welcome to Express App - Home Page!!!')
})

app.get('/error',(req, res) => {
    throw new Error('Broken...')
})

//start server
app.listen(3000, () => {
    console.log('Express Server is running')
})
...................................................................................
			Built in and third party middlewares
...................................................................................
Built in middleware or third party middlewares

Middlewares are supplied as part of the express team, open source community.


in order to parse the incoming payload into javascript object.

Middleware
1.body-parser

 npm install body-parser


2.configure the middleware in app object.

const express = require('express')
const customerRouter = require('./routers/customer.router')
const bodyParser = require('body-parser')

const app = express()

//register middlewares
app.use(bodyParser.json())
.....................................................................................

How to introduce loggers in the application?

$ npm install morgan


const express = require('express')
const customerRouter = express.Router()

//customer data 
const customers = [{
    id: 1,
    name: 'A1'
},
{
    id: 2,
    name: 'A2'
},
{
    id: 1,
    name: 'A3'
}
]


customerRouter.use((req, res, next) => {
    console.log('Customer Router Middleware')
    next()
})

customerRouter.get('/', (req, res) => {
    //return
    res.status(200).json(customers)
})
customerRouter.get('/:id', (req, res) => {
    const params = req.params
    console.log(params)
    res.end('Customers-Get!!!' + params.id)
})
customerRouter.get('/search/bycity', (req, res) => {
    const params = req.query
    console.log(params)
    res.end('Customers-search!!!')
})


customerRouter.post('/create', (req, res) => {
    //read payload 
    const customer = req.body ; //read payload 
    console.log(customer)
    res.status(201).json({status:'Created'})
})


customerRouter.put('/update/:id', (req, res) => {
    const params = req.params
    console.log(params)
    res.end('Customers-UPDATE')
})
customerRouter.delete('/remove/:id', (req, res) => {
    res.end('Customers-Delete')
})
//
module.exports = customerRouter;
.....................................................................................
			Advanced Middlewares

1.Database Integration
http://expressjs.com/en/guide/database-integration.html

Mongodb - Demo

Req:
 Basics of mongodb knowledge
 Mongodb must have been installed.
	

Steps:

1.install mongodb database - either local or cloud or through docker.

2.npm install mongodb

3.database initalization.

db.js

const { MongoClient } = require("mongodb");

//connection string:
const connectionString = "mongodb://localhost:27017/demo";//process.env.ATLAS_URI;

//create connection
const client = new MongoClient(connectionString, {
    useNewUrlParser: true,
    useUnifiedTopology: true,
});
let _db;

//i want to share connection object to the application
module.exports = {
    connectToServer: function (callback) {
        client.connect(function (err, db) {
            // Verify we got a good "db" object
            if (db) {
                _db = db.db("employees");
                console.log("Successfully connected to MongoDB.");
            }
            return callback(err);
        });
    },

    getDb: function () {
        return _db;
    },
}

router:
const express = require("express");

// recordRoutes is an instance of the express router.
// We use it to define our routes.
// The router will be added as a middleware and will take control of requests starting with path /record.
const recordRoutes = express.Router();

// This will help us connect to the database
const dbo = require("../db");

// This help convert the id from string to ObjectId for the _id.
const ObjectId = require("mongodb").ObjectId;


// This section will help you get a list of all the records.
recordRoutes.route("/list").get(function (req, res) {
  let db_connect = dbo.getDb("records");
  console.log('database prop =>',db_connect)
  db_connect
    .collection("records")
    .find({})
    .toArray(function (err, result) {
      if (err) throw err;
      res.json(result);
    });
});

// This section will help you get a single record by id
recordRoutes.route("/list/:id").get(function (req, res) {
  let db_connect = dbo.getDb();
  let myquery = { _id: ObjectId(req.params.id) };
  db_connect
    .collection("records")
    .findOne(myquery, function (err, result) {
      if (err) throw err;
      res.json(result);
    });
});

// This section will help you create a new record.
recordRoutes.route("/add").post(function (req, response) {
  let db_connect = dbo.getDb();
  let myobj = {
    name: req.body.name,
    position: req.body.position,
    level: req.body.level,
  };
  db_connect.collection("records").insertOne(myobj, function (err, res) {
    if (err) throw err;
    response.json(res);
  });
});

// This section will help you update a record by id.
recordRoutes.route("/update/:id").post(function (req, response) {
  let db_connect = dbo.getDb();
  let myquery = { _id: ObjectId(req.params.id) };
  let newvalues = {
    $set: {
      name: req.body.name,
      position: req.body.position,
      level: req.body.level,
    },
  };
  db_connect
    .collection("records")
    .updateOne(myquery, newvalues, function (err, res) {
      if (err) throw err;
      console.log("1 document updated");
      response.json(res);
    });
});

// This section will help you delete a record
recordRoutes.route("/:id").delete((req, response) => {
  let db_connect = dbo.getDb();
  let myquery = { _id: ObjectId(req.params.id) };
  db_connect.collection("records").deleteOne(myquery, function (err, obj) {
    if (err) throw err;
    console.log("1 document deleted");
    response.json(obj);
  });
});

module.exports = recordRoutes;

main
index.js
const express = require('express')
const customerRouter = require('./routers/customer.router')
const bodyParser = require('body-parser')
const morgan = require('morgan')
const fs = require('fs')
const path = require('path')
const employeeRouter = require('./routers/employee.router')
// get driver connection
const dbo = require("./db");

const app = express()

//register middlewares
app.use(bodyParser.json())
//logger
// create a write stream (in append mode)
const accessLogStream = fs.createWriteStream(path.join(__dirname, 'access.log'), { flags: 'a' })

// setup the logger
app.use(morgan('combined', { stream: accessLogStream }))

//connecting router with application object, so that routing will happen.
app.use('/api/customers', customerRouter);
app.use('/api/employees', employeeRouter)

// app.use((err, req, res, next) => {
//     res.status(500).send('something went wrong')
// })


//home page:
app.get("/", (req, res) => {
    res.end('Welcome to Express App - Home Page!!!')
})

//start server
app.listen(3000, () => {
    // perform a database connection when server starts
    dbo.connectToServer(function (err) {
        if (err) console.error(err);
    });
    console.log(`Server is running on port: ${3000}`);
});
.....................................................................................
			Debugging Node.js app in Vs code
.....................................................................................














